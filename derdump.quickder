#!/usr/bin/env python

import sys
import copy
import inspect

import optparse
import importlib

import quick_der.api as _api


opts = optparse.OptionParser ()
opts.add_option ('-c', '--colour', '--color',
		action='store_true', default=False, dest='colour',
		help='Print colourful output (loads Python module "colored", page with "less -R")')
opts.add_option ('-q', '--quick-der', '--quick_der', '--quickder', '--QuickDER',
		action='store', default=None, dest='quickder',
		help='Load a Python module with ASN.1 syntax, generated by Quick DER')
opts.add_option ('-a', '--asn1type', '--asn1', '--asn.1', '--ASN1', '--ASN.1',
		action='store', default=None, dest='asn1type',
		help='Expect the given ASN.1 type; validate the syntax and use its symbols')
(options,args) = opts.parse_args ()

if options.colour:
	from colored import fg, bg, attr
else:
	def attr (_col):
		return ''
	fg = attr
	bg = attr

if len (args) != 1:
	print 'Usage:  ' + attr ('bold') + sys.argv [0] + '[--colour] file.der' + attr (0)
	print 'Output: ' + nicemeaning ('MEANING') + ': ' + nicetag ('TAG') + ' ' + nicecontlen ('CONTLEN', 3) + ' ' + nicetagofs ('TAGOFS') + ' ' + nicenesting ('NESTING') + ', ' + niceclass ('CLASS') + ', ' + niceprimconstr ('PRIMCONSTR')
	sys.exit (1)

# Setup "qdmod" with a Quick DER module
#
qdmod = None
if options.quickder:
	import quick_der
	try:
		qdmod = importlib.import_module (options.quickder.lower (), package='quick_der')
	except:
		qdmod = importlib.import_module (options.quickder.lower ()                     )

# Setup "tag2type" with ASN.1 classes based on unique tags
#
tag2type = { }
for nm in [] if qdmod is None else dir (qdmod):
	nmdef = getattr (qdmod, nm)
	if inspect.isclass (nmdef):
		pck = getattr (nmdef, '_der_packer',None)
		if not pck:
			continue
		tag = ord (pck [0]) & 0xdf
		tag_class = (tag & 0xc0) >> 6
		tag_num = tag & 0x1f
		tag_key = (tag_class,tag_num)
		if tag_class in [0, 2]:
			# Universal and Contextual tags give poor hints
			pass
		elif tag2type.has_key (tag_key):
			# Multiple occurences of a tag cancel its hint
			tag2type [tag_key] = None
		else:
			# Possibly unique tag that might hint a type
			tag2type [tag_key] = nmdef

# Setup "asn1class" with a Quick DER class for the syntax
#
asn1class = None
if qdmod is None:
	# No type information will be collected
	pass
elif options.asn1type:
	# Explicit ASN.1 type will be expected
	try:
		asn1class = getattr (qdmod, options.asn1type.replace ('-', '_'))
		#TODO# issubclass(...)
	except:
		print 'Unkown ASN.1 type name'
		sys.exit (1)
	if not inspect.isclass (asn1class):
		print 'ASN.1 type name is not a Quick DER class'
		sys.exit (1)
else:
	# Fall back to tag2type for type hints
	pass

# The "ASN1Finger" class points at a position in the syntax
# while parsing it and it helps to generate symbols.
#
# Maybe one day this will become part of the Quick DER code base.
#
class ASN1Finger:

	DER_PACK_ENTER = 0x20
	DER_PACK_LEAVE = 0x00
	DER_PACK_END = 0x00
	DER_PACK_OPTIONAL = 0x3f
	DER_PACK_CHOICE_BEGIN = 0x1f
	DER_PACK_CHOICE_END = 0x1f
	DER_PACK_ANY = 0xdf

	DER_TAG_SEQUENCE = 0x10
	DER_TAG_SET = 0x11

	def __init__ (self, asn1class):
		self.depth = 0
		self.inner = None
		self.asn1class = asn1class
		self.packer = asn1class._der_packer
		self.recipe = asn1class._recipe
		self.pckhead = 0
		self.pcknext = None
		#TODO# self.vartodo = TODO: [ (varnm,grammar) ]

	def _offset_error (self):
		raise Exception ('TRAILING DATA AFTER ASN.1 GRAMMAR')

	def _syntax_error (self, stxok_tags):
		self.asn1class = None
		tagstr = ' OR '.join ([ '0x%02x' % (tag & 0xdf,) for tag in stxok_tags ])
		if tagstr == '':
			tagstr = 'NO TAG'
		raise Exception ('SYNTAX ERROR, EXPECTED ' + tagstr)

	def _parse_optional (self, tag, pckhere):
		"""Partial parser; return (pcknext,stxok_tags->pckhere);
		   Welcomes one tag, as well as what comes next.
		   Recurses if the second tag is also optional.
		"""
		# print '_parse_optional (0x%02x, %d/%d)' % (tag,pckhere,len(self.packer))  #DEBUG#
		assert (tag == self.DER_PACK_OPTIONAL)
		pckhere += 1
		(pckhere,oneok_tags) = self._parse (pckhere)
		(pckhere,twook_tags) = self._parse (pckhere)
		allok_tags = {}
		allok_tags.update (oneok_tags)
		allok_tags.update (twook_tags)
		return (pckhere,allok_tags)

	def _parse_choice (self, tag, pckhere):
		"""Partial parser; return (pcknext,stxok_tags->pckhere);
		   Chases until DER_PACK_CHOICE_END
		"""
		# print '_parse_choice (0x%02x, %d/%d)' % (tag,pckhere,len(self.packer))  #DEBUG#
		assert (tag == self.DER_PACK_CHOICE_BEGIN)
		pckhere += 1
		retok_tags = {}
		# print 'CHOICE will be tested first at offset %d/%d' % (pckhere,len (self.packer)) #DEBUG#
		while ord (self.packer [pckhere]) != self.DER_PACK_CHOICE_END:
			# print 'CHOICE not END with tag 0x%02x at offset %d' % (ord(self.packer [pckhere]),pckhere) #DEBUG#
			(pckhere,subok_tags) = self._parse (pckhere)
			retok_tags.update (subok_tags)
			# print 'CHOICE now allow tags', ','.join (map (lambda (d,o): '0x%02x at %d' % (d,o), retok_tags.items ())), 'and investigates offset', pckhere
			# print 'CHOICE will be tested next at offset %d/%d' % (pckhere,len (self.packer)) #DEBUG#
		pckhere += 1
		return (pckhere,retok_tags)

	def _parse_any (self, tag, pckhere):
		"""Partial parser; return (pcknext,stkok_tags->pckhere);
		   Welcomes anything at all
		"""
		# print '_parse_any (0x%02x, %d/%d)' % (tag,pckhere,len(self.packer))  #DEBUG#
		assert (tag == self.DER_PACK_ANY)
		allok_tags = { (tag_class << 6) + tag_num : pckhere
		               for tag_class in range (4)
		               for tag_num in range (32)
		             }
		pckhere += 1
		return (pckhere,allok_tags)

	def _parse_nesting (self, tag, pckhere):
		"""Partial parser; return (pcknext,stxok_tags->pckhere);
		   Enters into nested structures; this is mostly
		   useful to skip beyond such nested structures
		"""
		# print '_parse_nesting (0x%02x, %d/%d)' % (tag,pckhere,len(self.packer))  #DEBUG#
		assert ((tag & self.DER_PACK_ENTER) != 0x00)
		retok_tags = { tag:pckhere }
		pckhere += 1
		nestcount = 1
		while nestcount > 0 and pckhere < len (self.packer):
			tag = ord (self.packer [pckhere])
			pckhere += 1
			if tag == self.DER_PACK_LEAVE:
				nestcount -= 1
				# print '_parse_nesting() decreased to', nestcount, 'at', pckhere-1 #DEBUG#
			elif tag in [self.DER_PACK_ANY, self.DER_PACK_OPTIONAL]:
				# Special cases; skip
				pass
			elif (tag & self.DER_PACK_ENTER) != 0x00:
				nestcount += 1
				# print '_parse_nesting() increased to', nestcount, 'at', pckhere-1 #DEBUG#
		# print '_parse_nesting() now at offset', pckhere #DEBUG#
		return (pckhere,retok_tags)

	def _parse (self, pckhere):
		"""Partial parser; point of entry and recursion;
		   Reads the tag and decides what partial parser
		   to call for continuation
		   Returns (pckhere,stxok_tags->pckhere)
		"""
		# print '_parse (----, %d/%d)' % (pckhere,len(self.packer))  #DEBUG#
		if pckhere >= len (self.packer):
			retval = (pckhere, {})
		tag = ord (self.packer [pckhere])
		if tag == self.DER_PACK_LEAVE:
			retval = (pckhere+1, {})
		elif tag == self.DER_PACK_ANY:
			retval = self._parse_any (tag, pckhere)
		elif tag == self.DER_PACK_OPTIONAL:
			retval = self._parse_optional (tag, pckhere)
		elif tag == self.DER_PACK_CHOICE_BEGIN:
			retval = self._parse_choice (tag, pckhere)
		elif (tag & self.DER_PACK_ENTER) != 0x00:
			retval = self._parse_nesting (tag, pckhere)
		else:
			retok_tags = { tag:pckhere }
			retval = (pckhere+1,retok_tags)
		# print '_parse() returns', retval #DEBUG#
		return retval

	def _count_fieldnum (self, pckhere):
		"""Count the DER_PACK_STORE statements before pckhere, and
		   use that to indicate the variable number at pckhere.
		"""
		#TODO:BOTH_USE_IT# assert ((ord (self.packer [pckhere]) & self.DER_PACK_ENTER) == 0x00)
		stovarnum = 0
		for prioridx in range (pckhere):
			tag = ord (self.packer [prioridx])
			if (tag & self.DER_PACK_ENTER) == 0x00:
				if tag not in [self.DER_PACK_LEAVE, self.DER_PACK_CHOICE_BEGIN, self.DER_PACK_CHOICE_END]:
					stovarnum += 1
		return stovarnum

	def _fieldnum2info (self, recipe, fieldnum, context=None):
		"""Look through a recipe to find the recipe that is
		   nearest to its number and, therefore, the supposed
		   recipe to contain the field.  Nearest means the
		   highest-numbered field not exceeding fieldnum.

		   The naming context is passed, but defaults to the
		   current ASN.1 module's context.  Recursive calls
		   will set this accordingly when they move to other
		   ASN.1 modules.

		   On success, return the tuple with the nearest
		   (fieldnum,name,typename,typeclass)
		   or (None,?,?,?) when nothing is found.

		   TODO: This procedure would be faster with sorting.
		"""
		# if type (recipe) != tuple:
		# 	# Probably a dict
		# 	print 'Cannot parse non-tuple recipe:', recipe  #DEBUG/ASSERT#
		# 	return (None,None)
		assert (type (recipe) == tuple)
		assert (fieldnum >= 0)
		ctx = context or self.asn1class._context
		nrs_number = None
		nrs_naming = None
		nrs_typenm = None
		nrs_typcls = None
		# _SEQOF/_SETOF -> Ignore, but TODO: Should we do something more useful?
		if recipe [0] in ['_SEQOF','_SETOF']:
			pass
		# _NAMED -> Iterate over names to find the nearest, prefix a symbol on return
		elif recipe [0] == '_NAMED':
			for (fnm,fdef) in recipe [1].items ():
				# print 'Looking into', fnm, 'defined as', fdef  #DEBUG#
				if type (fdef) != tuple:
					print 'Skipping name', fnm, 'with non-tuple recipe:', fdef  #DEBUG/ASSERT#
					continue
				(new_number,new_naming,new_typenm,new_typcls) = \
						self._fieldnum2info (fdef, fieldnum, context=ctx)
				if new_number is not None:
					# print 'Overrule if sought >= new > sofar:', fieldnum, new_number, (nrs_number or -1)  #DEBUG#
					if fieldnum == new_number:
						# Exact match
						# print 'Exact match'  #DEBUG#
						nrs_number = new_number
						nrs_typenm = new_typenm
						nrs_typcls = new_typcls
						if new_naming is not None:
							nrs_naming = fnm + '.' + new_naming
						else:
							nrs_naming = fnm
					elif fieldnum > new_number > (nrs_number or -1):
						# Closer match than what we have (including First match)
						# print 'Closer match'  #DEBUG#
						nrs_number = new_number
						nrs_typenm = new_typenm
						nrs_typcls = new_typcls
						nrs_naming = fnm + '.' + new_naming
				elif fdef [0] == '_TYPTR' and fdef [2] == fieldnum:
					# print 'Direct use of field (probably a primitive)'  #DEBUG#
					nrs_number = fieldnum
					nrs_typenm = None
					nrs_typcls = None
					nrs_naming = fnm
		# _TYPTR -> Recurse to type and offset field and prefix a symbol on return
		elif recipe [0] == '_TYPTR':
			sub_fldnum = fieldnum - recipe [2]
			if sub_fldnum >= 0:
				tyname = recipe [1][0]
				if tyname [:5] != '_api.':
					assert ctx.has_key (tyname), 'No name %s in context %s' % (tyname,ctx ['__name__'])
					typtr = ctx [tyname]
					(nrs_number,nrs_naming,nrs_typenm,nrs_typcls) = \
							self._fieldnum2info (typtr._recipe, sub_fldnum, context=ctx)
					if nrs_number is not None:
						nrs_number += recipe [2]
						if nrs_typenm is not None:
							nrs_typenm = tyname + '.' + nrs_typenm
						else:
							nrs_typenm = tyname
							nrs_typcls = typtr
		# Say what?!?
		else:
			raise Exception ('Unexpected recipe ingredient ' + str (recipe [0]))
		return (nrs_number,nrs_naming,nrs_typenm,nrs_typcls)

	def outer_typename (self):
		"""Return a type name only if the outside of this class is active.
		"""
		if self.pckhead == 0:
			return self.asn1class.__name__.replace ('_', '-')
		else:
			return None

	def inner_typename (self):
		"""Return a type name representing an attribute's contents.
		"""
		# print 'Evaluating inner_typename() from', self.inner  #DEBUG#
		if self.inner is None:
			return None
		return self.inner.__name__

	def parse_tag_fieldname (self, (tag_class,tag_num)):
		"""Parse the next tag and try to return a type name based on ASN.1 grammar.
		   Return None to fall back to default strings (when no name is available,
		   or when processing an entry marked as ANY).
		   Names may be the name of this class or a field name if it is stored.
		   Raise an Exception string to report an error and stop trying to match.
		   An inner object may be prepared, to be used for nesting; any older tag
		   parsing may have led to an inner object, if so it will be ignored.
		"""
		self.inner = None
		retval = None
		actual_tag = (tag_class << 6) | tag_num
		(pcknext,stxok_tags) = self._parse (self.pckhead)
		if stxok_tags.has_key (actual_tag):
			# The packer wants to store this tag in a field
			# print 'parse_tag_fieldname() wants to store this tag in a field' #DEBUG#
			pcktag = stxok_tags [actual_tag]
			self.pcknext = None
			self.pckhead = pcktag + 1
			# print 'Next packer offset is', self.pckhead #DEBUG#
			fieldnum = self._count_fieldnum (pcktag)
			# print 'Field number is %d/%d' % (fieldnum, self.asn1class._numcursori) #DEBUG#
			assert (0 <= fieldnum < self.asn1class._numcursori)
			# fnm_sub = self._fieldnum2namedef (self.recipe, fieldnum)
			# if fnm_sub is not None:
			# 	(fieldname,subdef) = fnm_sub
			# 	retval = fieldname
			# 	print 'Setting self.inner =', subdef
			# 	self.inner = subdef
			(nrs_number,nrs_naming,nrs_typenm,nrs_typcls) = \
					self._fieldnum2info (self.recipe, fieldnum)
			if nrs_number == fieldnum:
				# Optional information
				self.inner = nrs_typcls
				retval = nrs_naming
			else:
				print 'Mismatch in field info:', nrs_number, '!=', fieldnum, 'so ditching', nrs_naming
				retval = None
		elif stxok_tags.has_key (actual_tag + self.DER_PACK_ENTER):
			# The packer wants to enter this tag
			# print 'parse_tag_fieldname() wants to enter this tag' #DEBUG#
			pcktag = stxok_tags [actual_tag + self.DER_PACK_ENTER]
			self.pcknext = pcknext
			self.pckhead = pcktag + 1
			# Find the first field and its index -- it exists, we are holding the data!
			fieldnum = self._count_fieldnum (pcktag)
			assert (0 <= fieldnum < self.asn1class._numcursori)
			(nrs_number,nrs_naming,nrs_typenm,nrs_typcls) = \
					self._fieldnum2info (self.recipe, fieldnum)
			self.inner = nrs_typcls
			retval = nrs_naming.rsplit ('.', 1) [0]  #ROUGH# Strip the last, it is an attribute
			# print 'Nested packer offset is', self.pckhead, 'after nesting it is', self.pcknext #DEBUG#
			#TODO# if RECIPE CAN BE FOUND
			#TODO#    Recipe may give us a type name to return
			#TODO#    Derive self.inner from recipe too
			#TODO# NEXT LINE, if SHOULD THEN BE elif:
		elif stxok_tags == []:
			# Attempted to read beyond ASN.1 grammar
			self._offset_error ()
		else:
			# The packer did not recognise the tag
			self._syntax_error (stxok_tags)
		return retval

	def nested_asn1finger (self):
		"""Having parsed a meaning, there may be an inner object.  Return it if
		   this is the case, otherwise return self.  When this is not called, the
		   inner object will be silently skipped when parsing the next tag.
		"""
		assert (0 <= self.pckhead-1 < len (self.packer))
		if self.pcknext is None:
			# ANY may cause unsupported nested call
			#TODO# mark inner with type ANY?
			return None
		assert ((ord (self.packer [self.pckhead-1]) & self.DER_PACK_ENTER) != 0x00)
		inner_class = self.inner
		self.inner = None
		pcknext = self.pcknext
		self.pcknext = None
		nested_me = copy.copy (self)  #shallow#
		self.pckhead = pcknext
		if inner_class is not None:
			# print 'Redirecting nested asn1finger to', inner_class  #DEBUG#
			nested_me.__init__ (inner_class)
			nested_me.pckhead += 1
		return nested_me

if asn1class is not None:
	asn1finger = ASN1Finger (asn1class)
else:
	asn1finger = None

class2str = {
	0: 'Universal',
	1: 'Application',
	2: 'Contextual',
	3: 'Private'
}

pc2str = {
	0: 'Primitive',
	1: 'Constructed'
}

universal2str = {
	0: 'End-Of-Content',
	1: 'BOOLEAN',
	2: 'INTEGER',
	3: 'BITSTRING',
	4: 'OCTETSTRING',
	5: 'NULL',
	6: 'OID',
	7: 'Object-Descriptor',
	8: 'EXTERNAL',
	9: 'REAL',
	10: 'ENUMERATED',
	11: 'EMBEDDED PDV',
	12: 'UTF8String',
	13: 'RELATIVE-OID',
	# 14: '*****',
	# 15: '*****',
	16: 'SEQUENCE (OF)',
	17: 'SET (OF)',
	18: 'NumericString',
	19: 'PrintableString',
	20: 'T61String',
	21: 'VideotexString',
	22: 'IA5String',
	23: 'UTCTime',
	24: 'GeneralizedTime',
	25: 'GraphicString',
	26: 'VisibleString',
	27: 'GeneralString',
	28: 'UniversalString',
	29: 'CHARACTER STRING',
	30: 'BMPString',
	# 31: '*****'
}


def niceerror (s):
	return bg ('red') + fg ('yellow') + attr ('bold') + s + attr (0)

def nicemeaning (s):
	return attr ('bold') + s + attr (0)

def nicetag (ds):
	if type (ds) == int:
		ds = 'tag 0x%02x' % ds
	return fg ('green') + ds + attr (0)

def nicecontlen (ds, depth):
	if type (ds) == int:
		ds = str (ds)
	return fg ('magenta') + '#' * depth + ds + attr (0)

def nicetagofs (ds):
	if type (ds) == int:
		ds = str (ds)
	return fg ('cyan') + '@' + ds + attr (0)

def nicenesting (ad):
	if type (ad) == type ([]):
		ad = len (ad)
	return fg ('light_blue') + '^' + str (ad) + attr (0)

def niceclass (ds):
	if type (ds) == int:
		ds = class2str [ds]
	return attr ('dim') + ds + attr (0)

def niceprimconstr (ds):
	if type (ds) == bool:
		ds = int (ds)
	if type (ds) == int:
		ds = pc2str [ds]
	return attr ('dim') + ds + attr (0)

der = open (args [0], 'r').read (65537)
ofs = 0

def eof ():
	global ofs, der
	return ofs >= len (der)

def read1 ():
	global ofs, der
	if eof ():
		print niceerror ('ATTEMPTED READ BEYOND EOF (RETURNING 0x00)')
		return 0
	else:
		ofs = ofs + 1
		return ord (der [ofs-1])

nesting = []

while not eof ():

	# Pop when we have reached ends of nesting
	while nesting != [] and ofs >= nesting [-1][0]:
		(new_ofs,asn1finger) = nesting.pop ()
		if ofs > new_ofs:
			print '  ' * len (nesting) + niceerror ('READ OFFSET %d EXCEEDS ENCAPSULATION %d (RETURNING)' % (ofs, new_ofs))
		ofs = new_ofs

	# Read a tag
	ofs_tag = ofs
	tag = read1 ()
	tag_class = (tag & 0xc0) >> 6
	tag_pc = (tag & 0x20) != 0
	tag_num = tag & 0x1f
	tag_key = (tag_class,tag_num)

	# Read the length
	lenlen = read1 ()
	if lenlen & 0x80 == 0:
		leng = lenlen
		lenlen = 1
	else:
		lenlen = lenlen - 0x80 + 1
		leng = 0
		i = 1
		while i < lenlen:
			leng <<= 8
			leng = leng + read1 ()
			i = i + 1

	# If no syntax yet, look for a ASN.1 class hint
	if asn1class is None:
		if tag2type.has_key (tag_key):
			asn1class = tag2type [tag_key]
			asn1finger = ASN1Finger (asn1class)

	# Produce an extra line to report the type, if we just entered one
	outer_type = None
	if asn1finger is not None:
		outer_type = asn1finger.outer_typename ()
		# if outer_type is not None:
		# 	print '  ' * len (nesting) + attr ('bold') + attr ('underlined') + outer_type + '.' + attr (0)

	# Find the "fieldname" to describe the tag, if defined as an ASN.1 symbol
	fieldname = None
	inner_type = None
	try:
		if asn1finger is not None:
			# print 'Parsing tag %s at %d' % (str (tag_key),ofs_tag) #DEBUG#
			fieldname = asn1finger.parse_tag_fieldname (tag_key)
		if fieldname is not None:
			inner_type = asn1finger.inner_typename ()
	except Exception as e:
		print '  ' * len (nesting) + niceerror (str (e))
		asn1finger = None
		asn1class = None
		fieldname = None
		# raise #DEBUG#

	# Find the generic "meaning" from tag_class and tag_num
	if tag_class == 0:
		if universal2str.has_key (tag_num):
			meaning = universal2str [tag_num]
		else:
			meaning = niceerror ('FUNNY TAG')
	elif tag_class == 1:
		meaning = '[APPLICATION ' + str (tag_num) + ']'
	elif tag_class == 2:
		meaning = '[' + str (tag_num) + ']'
	else:
		meaning = '[PRIVATE ' + str (tag_num) + ']'

	# If an "outer_type" or "fieldname" was found, prefix it to the (then less shiny) generic "meaning"
	if outer_type is not None or fieldname is not None:
		meaning = (outer_type or '') + '.' + (fieldname or '') + attr (0) + ' ' + (inner_type or meaning)

	# Print an indented line with information, in technicolour
	print ('%s%s: %s %s %s %s, %s, %s' % (
			'  ' * len (nesting),
			nicemeaning (meaning), nicetag (tag),
			nicecontlen (leng, lenlen),
			nicetagofs (ofs - lenlen - 1),
			nicenesting (nesting),
			niceclass (tag_class),
			niceprimconstr (tag_pc) ) )

	# Construct and print a value string for primitives
	if tag_pc == 0 and leng > 0:
		print '  ' * ( len (nesting) + 1 ),
		cstr = ''
		ival = None
		ostr = ''
		oval = None
		bseq = []
		bval = -8
		while leng > 0:
			ch = read1 ()
			print '%02x' % ch,
			if 32 <= ch < 127:
				cstr = cstr + chr (ch)
			else:
				cstr = cstr + '.'
			if ival is None:
				ival = -1 if ch >= 128 else 0
			ival = (ival << 8) | ch
			if oval is None:
				ostr = str (ch / 40) + '.' + str (ch % 40)
				oval = 0
			else:
				oval = (oval << 7) | (ch & 0x7f)
				if ch & 0x80 == 0:
					ostr = ostr + '.' + str (oval)
					oval = 0
			for b in range (8):
				if ((ch << b) & 0x80) == 0x80:
					bseq.append (bval + b)
			bval += 8
			leng = leng - 1
		if tag == 0x01:
			cstr = attr ('bold') + ('TRUE' if ival != 0 else 'FALSE') + attr (0)
		elif tag == 0x06:
			cstr = attr ('bold') + ostr + attr (0)
		elif tag in [0x02,0x0a]:
			cstr = attr ('bold') + str (ival) + attr (0)
		elif tag == 0x03:
			if len (bseq) <= 32:
				cstr = '{' + ','.join (
					[ attr ('bold') + str (b) + attr (0)
					  for b in bseq
					  if b >= 0
					]) + '}'
			else:
				cstr = None
		else:
			cstr = '"' + attr ('bold') + cstr + attr (0) + '"'
		if cstr is not None:
			print '==', cstr
		else:
			print

	# Use nesting to enter the parser into constructed tags
	if tag_pc != 0:
		# print 'Now at', ofs, 'adding', leng, 'pushing', ofs + leng
		nesting.append ( (ofs+leng,asn1finger) )
		if asn1finger != None:
			asn1finger = asn1finger.nested_asn1finger ()
		else:
			asn1finger = None
		if asn1finger is None:
			asn1class = None

# Finish by unrolling any nesting
while nesting != []:
	(new_ofs,_) = nesting.pop ()
	if ofs != new_ofs:
		print '  ' * len (nesting) + niceerror ('BAD NESTING, OFFSET IS %d INSTEAD OF %d (CONTINUING)' % (ofs, new_ofs))
	ofs = new_ofs

